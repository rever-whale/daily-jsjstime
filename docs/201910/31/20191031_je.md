## 비동기 이벤트 처리 방법
과거에 ajax 요청으로 서버에서 데이터가 올때까지 UI가 멈추지 않고, 기다리는 작업을 순차적으로 실행하기 위해 callback 을 사용했다면 
ES6 부터는 promise 와 ES7 async, await 방법을 사용한다.
내부 콜백 함수를 람다 표현식으로 표현해서 개별 컴포넌트로 분리하면 콘텍스트 흐름이 현재 함수의 콘텍스트를 정리하고 
새 콘텍스트를 만들어 다음 함수를 지원하게 되는 콘택스트 스택의 효율이 좋아진다. 하지만 클로저가 에워싼 마지막 참조 레펀런스를 가져 중복값이 발생한다.
이럴때는 반환받아야할 객체의 스코프를 ajax 요청을 하는 함수 안으로 밀어넣어 서로 연결을 지어야한다.

시간이 오래 걸리는 연산은 일급객체로 만들어야한다.
프로미스는 구조를 눌러펴고, 합성하고, 로직을 통합하기 위한 모나드의 개념이다. 프로미스 생성자는 비동기를 감싼 함수를 하나 받는다.
어떤 연산을 수행하고 다시 프로미스 형태로 되돌리는 then 메서드를 사용한다. 모두 성공 콜백만 넣고 모든 에러 처리는 마지막 단계의 catch 메서드에게 일임하는 방법도 있다.
프로미스 체이닝을 위해 함수를 프로미스화 해야한다.
``` js
var json = function() {
  return new Promise(function(resolve, reject) {
    if(req.status === 200) {
      resolve(data)
    } else {
      reject(new Error(req.data))
    }
  })
}
```

promise.all을 이용하면 이터러블(반복 가능)인수에 포함된 모든 promise가 모이는 즉시 결과 promise 로 리턴된다.


## 브라우저 패턴
#### DOM 스크립팅
- 화면을 다시그리고(repaint), 엘리먼트들을 재구조화(reflow) 하는데 비용이 많이 든다. 문서 조각을 생성해 외부에서 수정한 후, 처리가 완전히 끝난 다음에 dom을 추가한다.
- 엘리먼트를 생성할때마다 문서를 변경하지 않고 마지막에 단 한번만 변경한다. 
- 화면을 다시 그리고 재계산하는 과정도 한번만 실행된다.
  
```js
var frag = dcoumenet.createDocumentFragment()
frag.appendChild()
document.body.appendChild(frag)
```  

#### 성능 최적화를 위해 스크립트를 로드하는 패턴
- 브라우저는 여러개의 요소를 동시에 다운로드 하는데 외부 스크립트를 만나면 스크립트가 다운로드되고 파싱되어 실행될 때까지 나머지 파일 다운로드를 중단한다. 
  이 때문에 엘리먼트를 페이지의 마지막부분</body> 태그 바로 앞에 위치시켜야한다.
  
- 게으른 로딩 : 페이지를 초기화하고 이벤트 핸들러를 UI 엘리먼트에 붙이는 핵심코드를 첫번째, 사용자 인터렉션이나 다른 조건들을 두번째 부분으로 나눈다

#### 자바스크립트 배포단계 : 코드 압축과 gzip 압축
  코드 압축의 효과는 주석과 공백을 얼마나 많이 사용했는지에 따라 달라질 수 있고, 스크립트 파일은 항상 gzip으로 압축을 적용해 전송한다.