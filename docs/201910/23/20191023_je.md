# 브라우저의 렌더링 과정
브라우저의 핵심 기능은 사용자가 사용하는 웹페이지를 서버에 요청하고 응답을 받아 표시를 한다. 
이때 서버로부터 HTML, CSS, Javascript, 이미지 등을 받아 렌더링 엔진인 HTML 파서와 CSS 파서에 의해 파싱되어
DOM, CSSDOM 트리로 변환되고 렌더트리로 결합되어 웹페이지로 제공된다.
자바스크립트는 렌더링 엔진이 아닌 자바스크립트 엔진으로 처리한다. 
스크립트 태그를 만나면 DOM 생성 프로세스를 중지하고 자바스크립트 엔진으로 제어권을 넘긴다. src 어트리뷰트에 정의된 자바스크립트 파일을 로드하고 실행이 완료되면 브라우저가 중지된 시점부터 DOM 생성을 재개한다.

이처럼 브라우저는 동기적으로 HTML, CSS, 자바스크립트를 처리한다. 

# 동기, 비동기 통신이란
서버에 요청을 했을 때, 응답이 늦게 오는 경우엔 동기의 경우엔 순차적으로 처리해야하므로 계속 기다리게 되어 프론트에서는 성능이슈가 발생하게 된다.
요청과 응답이 동시에 일어나지 않는 의미에서 비동기는 콜백으로 데이터를 받아 처리하게 되므로 성능이슈를 줄일 수 있다.


# vue.js 의 장단점을 설명
vue.js 는 러닝커버가 낮아 배우기가 쉽고 성능이 빠르고, 앵귤러의 데이터 바인딩 특성과 리액트의 가상돔 가반 렌더링 특징을 모두 가지고 있다. 

# vue.js 의 라이프 사이클에 대하여
beforeCreate, created, beforeMount, mounted, beforeUpdate, updated, beforeDestory, destoryed 8개의 사이클.
인스턴스 생성, 내용을 갱신, 제거. 

beforeCreate: data와 methods 속성이 아직 인스턴스에 정의되지 않음.
created: 인스턴스가 생성되어 fetchData() 와 같은 로직을 실행할 수 있다. data와 methods 속성에 접근이 가능하다.
beforeMount: render 함수가 호출되기 직전의 로직을 추가.
mounted: 화면 요소를 제어할 수 있는 단계.
beforeUpdate: el 에서 지정된 속성들이 화면에 치환됨. $watch 에서 감지. 데이터가 변경되면 가상 돔으로 화면을 다시 그리기 전 호출단계.
데이터 값을 갱신하는 로직을 넣어준다.
updated: 변경 데이터의 화면요소(dom) 과 관련된 로직을 추가한다.
beforeDestory: 뷰 인스턴스의 데이터를 삭제하기에 좋음
destoryed: 뷰 인스턴스가 파괴되고 나서 호출됨


# vue.js 에서 서드파티 라이브러리를 참조해 그리는 방법
상위 컴포넌트에서 props 로 변경된 데이터를 보내주고 하위 컴포넌트에서 watch 로 감지해서 갱신해준다.

# MVVM 과 MVC 패턴의 차이
ViewModel 로 나눈 이유는 화면의 요소를 제어하는 코드와 제어 로직을 분리하여 코드를 직관적으로 읽고, 유지보수를 쉽게 하기 위함이다.
백엔드와 프론트엔드 로직을 분리하는 디자인 패턴.
vue js 에서 보면, 돔 리스너와 데이터 바인딩을 (*.vue) 파일에 작업한다. 


# 클로저란 무엇이며 왜 이러한 패턴을 사용하는가
함수가 종료되었을 때, 실행컨텍스트가 사라지는데 이때 내부 함수는 외부 함수의 렉시컬 환경(변수)을 기억하게 되는 걸 말한다. 
외부에서 접근할 수 없게 private 한 함수를 만들 수 있다. 

# CORS란
다른 도메인의 접근을 제한한 정책, cors 를 허용해서 사용을 해야한다.
