# 브라우저의 렌더링 과정
브라우저의 핵심 기능은 사용자가 사용하는 웹페이지를 서버에 요청하고 응답을 받아 표시를 한다. 
이때 서버로부터 HTML, CSS, Javascript, 이미지 등을 받아 렌더링 엔진인 HTML 파서와 CSS 파서에 의해 파싱되어
DOM, CSSDOM 트리로 변환되고 렌더트리로 결합되어 웹페이지로 제공된다.
자바스크립트는 렌더링 엔진이 아닌 자바스크립트 엔진으로 처리한다. 
스크립트 태그를 만나면 DOM 생성 프로세스를 중지하고 자바스크립트 엔진으로 제어권을 넘긴다. src 어트리뷰트에 정의된 자바스크립트 파일을 로드하고 실행이 완료되면 브라우저가 중지된 시점부터 DOM 생성을 재개한다.

이처럼 브라우저는 동기적으로 HTML, CSS, 자바스크립트를 처리한다. 

# 동기, 비동기 통신이란



# vue.js 의 장단점을 설명
vue.js 는 러닝커버가 낮아 배우기가 쉽고 성능이 빠르고, 앵귤러의 데이터 바인딩 특성과 리액트의 가상돔 가반 렌더링 특징을 모두 가지고 있다. 

# vue.js 의 라이프 사이클에 대하여
beforeCreate, created, beforeMount, mounted, beforeUpdate, updated, beforeDestory, Destoryed 8개의 사이클.
인스턴스 생성, 내용을 갱신, 제거. 

beforeCreate: data와 methods 속성이 아직 인스턴스에 정의되지 않음.
created: 인스턴스가 생성되어 fetchData() 와 같은 로직을 실행할 수 있다. data와 methods 속성에 접근이 가능하다.
beforeMount: render 함수가 호출되기 직전의 로직을 추가.
mounted: 화면 요소를 제어할 수 있는 단계.
beforeUpdate: el 에서 지정된 속성들이 화면에 치환됨. $watch 에서 감지. 데이터가 변경되면 가상 돔으로 화면을 다시 그리기 전 호출단계.
데이터 값을 갱신하는 로직을 넣어준다.
updated: 변경 데이터의 화면요소(dom) 과 관련된 로직을 추가한다.



# vue.js 에서 서드파티 라이브러리를 참조할 수 있는 방법

# MVVM 과 MVC 패턴의 차이
ViewModel 로 나눈 이유는 화면의 요소를 제어하는 코드와 제어 로직을 분리하여 코드를 직관적으로 읽고, 유지보수를 쉽게 하기 위함이다.
백엔드와 프론트엔드 로직을 분리하는 디자인 패턴.
vue js 에서 보면, 돔 리스너와 데이터 바인딩을 (*.vue) 파일에 작업한다. 


# 클로저란 무엇이며 왜 이러한 패턴을 사용하는가


